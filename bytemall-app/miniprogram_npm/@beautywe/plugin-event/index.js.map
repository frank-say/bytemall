{"version":3,"sources":["event.js","../package.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar _package = _interopRequireDefault(require(\"../package.json\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar eventSplitter = /\\s+/;\n\nvar eventsApi = function eventsApi(obj, action, name, rest) {\n  if (!name) return true; // Handle event maps.\n\n  if (_typeof(name) === 'object') {\n    for (var key in name) {\n      obj[action].apply(obj, _toConsumableArray([key, name[key]].concat(rest)));\n    }\n\n    return false;\n  } // Handle space separated event names.\n\n\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n\n    for (var i = 0, l = names.length; i < l; i++) {\n      obj[action].apply(obj, _toConsumableArray([names[i]].concat(rest)));\n    }\n\n    return false;\n  }\n\n  return true;\n};\n\nvar triggerEvents = function triggerEvents(events, args) {\n  var ev,\n      i = -1,\n      l = events.length,\n      a1 = args[0],\n      a2 = args[1],\n      a3 = args[2];\n\n  switch (args.length) {\n    case 0:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx);\n      }\n\n      return;\n\n    case 1:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx, a1);\n      }\n\n      return;\n\n    case 2:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx, a1, a2);\n      }\n\n      return;\n\n    case 3:\n      while (++i < l) {\n        (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n      }\n\n      return;\n\n    default:\n      while (++i < l) {\n        (ev = events[i]).callback.apply(ev.ctx, args);\n      }\n\n  }\n};\n\nvar _once = function _once(func) {\n  var ran = false,\n      memo;\n  return function () {\n    if (ran) return memo;\n    ran = true;\n    memo = func.apply(this, arguments);\n    func = null;\n    return memo;\n  };\n};\n\nvar Events = {\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  on: function on(name, callback, context) {\n    if (!eventsApi(this.event, 'on', name, [callback, context]) || !callback) return this;\n    this._events || (this._events = {});\n    var events = this._events[name] || (this._events[name] = []);\n    events.push({\n      callback: callback,\n      context: context,\n      ctx: context || this\n    });\n    return this;\n  },\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, it will be removed.\n  once: function once(name, callback, context) {\n    if (!eventsApi(this.event, 'once', name, [callback, context]) || !callback) return this;\n    var self = this;\n\n    var once = _once(function () {\n      self.event.off(name, once);\n      callback.apply(this, arguments);\n    });\n\n    once._callback = callback;\n    return this.event.on(name, once, context);\n  },\n  // Remove one or many callbacks.\n  // If `context` is null, removes all callbacks with that function.\n  // If `callback` is null, removes all callbacks for the event.\n  // If `name` is null, removes all bound callbacks for all events.\n  off: function off(name, callback, context) {\n    var retain, ev, events, names, i, l, j, k;\n    if (!this._events || !eventsApi(this.event, 'off', name, [callback, context])) return this;\n\n    if (!name && !callback && !context) {\n      this._events = {};\n      return this;\n    }\n\n    names = name ? [name] : Object.keys(this._events);\n\n    for (i = 0, l = names.length; i < l; i++) {\n      name = names[i]; // eslint-disable-next-line no-cond-assign\n\n      if (events = this._events[name]) {\n        this._events[name] = retain = [];\n\n        if (callback || context) {\n          for (j = 0, k = events.length; j < k; j++) {\n            ev = events[j];\n\n            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {\n              retain.push(ev);\n            }\n          }\n        }\n\n        if (!retain.length) delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  trigger: function trigger(name) {\n    if (!this._events) return this;\n    var args = [].slice.call(arguments, 1);\n    if (!eventsApi(this, 'trigger', name, args)) return this;\n    var events = this._events[name];\n    var allEvents = this._events.all;\n    if (events) triggerEvents(events, args);\n    if (allEvents) triggerEvents(allEvents, arguments);\n    return this;\n  }\n};\n\nmodule.exports = function event() {\n  return {\n    name: 'event',\n    npmName: _package[\"default\"].name,\n    version: _package[\"default\"].version,\n    customMethod: Events\n  };\n};","module.exports = {\n  \"name\": \"@beautywe/plugin-event\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Event plugin for beautywe\",\n  \"main\": \"dist/event.js\",\n  \"scripts\": {\n    \"test\": \"nyc ava test/**/*.test.js\",\n    \"test:report\": \"nyc report --reporter=html\",\n    \"test:coverage\": \"nyc --reporter=html ava\",\n    \"build:pro\": \"rm -rf ./dist && node_modules/.bin/babel src -d dist\",\n    \"build:watch\": \"babel src --watch -d dist\",\n    \"code-check\": \"eslint src/**\",\n    \"code-fix\": \"eslint --fix src/**\",\n    \"lint\": \"git diff --cached --name-only | grep -E '\\\\.(js|jsx)$' | xargs eslint\",\n    \"commitmsg\": \"validate-commit-msg\",\n    \"commit\": \"git cz\"\n  },\n  \"keywords\": [\n    \"beautywe\",\n    \"beautywe-plugin\"\n  ],\n  \"author\": \"JerryC8080 (huangjerryc@gmail.com)\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/beautywe/beautywe-plugin-event.git\"\n  },\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/beautywe/beautywe-plugin-event/issues\"\n  },\n  \"homepage\": \"https://github.com/beautywe/beautywe-plugin-event#readme\",\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.0.0\",\n    \"@babel/core\": \"^7.0.0\",\n    \"@babel/preset-env\": \"^7.0.0\",\n    \"@babel/register\": \"^7.4.0\",\n    \"@beautywe/core\": \"^1.0.0\",\n    \"ava\": \"^1.4.1\",\n    \"babel-eslint\": \"^9.0.0\",\n    \"babel-plugin-array-includes\": \"^2.0.3\",\n    \"babel-plugin-istanbul\": \"^5.1.0\",\n    \"commitizen\": \"^3.0.5\",\n    \"eslint\": \"^2.13.1\",\n    \"eslint-config-airbnb\": \"^9.0.1\",\n    \"eslint-plugin-import\": \"^1.12.0\",\n    \"eslint-plugin-jsx-a11y\": \"^2.0.1\",\n    \"eslint-plugin-react\": \"^5.2.2\",\n    \"nyc\": \"^13.1.0\",\n    \"pre-commit\": \"^1.2.2\",\n    \"validate-commit-msg\": \"^2.14.0\"\n  },\n  \"config\": {\n    \"commitizen\": {\n      \"path\": \"./node_modules/cz-conventional-changelog\"\n    }\n  },\n  \"ava\": {\n    \"require\": [\n      \"@babel/register\"\n    ]\n  },\n  \"nyc\": {\n    \"sourceMap\": false,\n    \"instrument\": false\n  }\n}\n"]}